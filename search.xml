<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>不知道起什么名字</title>
      <link href="/2021/07/24/%E4%B8%8D%E7%9F%A5%E9%81%93%E8%B5%B7%E4%BB%80%E4%B9%88%E5%90%8D%E5%AD%97/"/>
      <url>/2021/07/24/%E4%B8%8D%E7%9F%A5%E9%81%93%E8%B5%B7%E4%BB%80%E4%B9%88%E5%90%8D%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正如这篇文字的标题一样，不知道该写什么东西，接下来写到哪算哪吧。</p><p>自从竞赛失利后，还是想了很多的，先不论比赛公平性怎么样，我们做的东西也就是个玩具罢了，要提高的还有很多。人要学会与自己和解，如果这样转换一下想法：花好多时间做了个大课设，还拿了奖和钱，心里是不是会好受很多？</p><p>眼界真的很重要，做一个东西，做到自己认为的最好，可能其实还是在一个比较低的level里的最好，在一个高的level下可能就很naive了。</p><h4 id="考研or工作？"><a href="#考研or工作？" class="headerlink" title="考研or工作？"></a>考研or工作？</h4><p>一个经典的二择问题，感觉这是有生以来最焦虑的时候了。</p><p>说到选择，回忆一下之前好像没做过什么选择：</p><pre><code>在我们小镇，小升初、初升高都只有一个学校，没的选择；竞赛除了信息没考虑过其他的；自主招生报名，没敢往上冲（因为成绩烂），有俩学校拿到优惠之后也就纠结了半天左右，去了离家比较近的学校；上大学后是否转专业，还是转了，当然不只是学费太贵了（软工要1w2,计科只要6k左右），也有感情方面原因（一段稀里糊涂的感情，回想起来自己做的非常差，累了也辜负了，说多了。。）。</code></pre><p>好像两个选择都不错，选哪个都有好多理由，但是必然要舍弃一个。</p><table><thead><tr><th align="center">考研</th><th align="center">秋招</th></tr></thead><tbody><tr><td align="center">好：研究生学历，更好的自己，选择更多，底气</td><td align="center">好：早赚钱，更好的自己</td></tr><tr><td align="center">不好：错过秋招，失败考虑二战or春招，三年</td><td align="center">不好：本科学历，工作后悔没读研</td></tr></tbody></table><p>真的好焦虑啊，也不知道选择哪条路更好，自己像机器一样在考研，也不知道能不能考上，不过自己还是想读研的，想看看科研是怎么一回事，看看上面的世界，虽然不知道自己适合不适合，但是选择了就得不后悔嘛。</p><p>现在劳资关系这么差，房价又高上天，对我这种家里出不了一分钱的来说，一二线定居好难，三线又没啥互联网产业，感觉干几年要回镇上下车间找个活干了。</p><p>自己现在就是这个状态，可能和大多数年轻人一样，对国家未来充满信心，对自己前途充满迷茫，蛋糕基本分完了，只能回去吃剩饭了。</p><p>有点消极了，and写的好乱，明天回家待一周，还是加油吧，一定不能躺平。</p><p>摸了会🐟，继续考研冲冲冲！</p><p>2021.7.24 于 山东大学（青岛）图书馆</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CDQ分治学习笔记</title>
      <link href="/2020/05/19/CDQ%E5%88%86%E6%B2%BB/"/>
      <url>/2020/05/19/CDQ%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>高中时的笔记，重新发布一下qwq。</p><h1 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a><a href="#CDQ分治" title="CDQ分治"></a>CDQ分治</h1><p>CDQ（<strong>陈丹琦</strong>）分治是一种特殊的分治方法。</p><p>它只能处理非强制在线的问题。</p><p>CDQ分治在维护一些动态的凸包、半平面交问题也有一定应用，然而本渣渣并不会。</p><p>CDQ分治基于时间分治，整体二分基于答案分治。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><a href="#步骤" title="步骤"></a>步骤</h2><p>1：将操作按照某个关键字排序</p><p>2；算出[L,mid]对[mid+1,R]的贡献</p><p>3；递归处理[L,mid]和[mid+1,R]</p><p>注：这里的区间指的是操作区间。</p><p>题目必须满足“修改独立，允许离线”两个条件。</p><p>这样的话我们把操作区间二分</p><p>会发现后一半的修改操作对前一半的询问操作不会产生影响</p><p>前后两个区间的联系只是前一半的修改操作会影响后一半的询问操作。</p><p>这个东西我们是可以事先算出来的：对于在满足某种限制下的答案贡献进行合并</p><p>用CDQ分治可以解决多维偏序问题</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a><a href="#例题" title="例题"></a>例题</h2><h3 id="一道简单的题目"><a href="#一道简单的题目" class="headerlink" title="一道简单的题目"></a><a href="#一道简单的题目" title="一道简单的题目"></a>一道简单的题目</h3><p>你有一个长度为N的棋盘，每个格子内有一个整数</p><p>两种操作：</p><p>1 x A 将格子x里的数字加上A</p><p>2 x y输出x y 这个区间内的数字和</p><p>1&lt;=N&lt;=100000,操作数不超过10000个，内存限制128M。</p><p>是不是很水啊。。。</p><p>几个做法</p><p>1.暴力O（NM）</p><p>2.线段树单点修改区间查询或树状数组维护差分数组O((n+m)logn)</p><p>3.分块修改O(1),查询O(q√N)</p><p>那么CDQ分治怎么做？</p><p>我们对x升序排序，然后按照时间分治，分治的时候记录一个前缀和<br>我们要保证贡献的计算不重不漏，根据上面的思路，是不是非常简单啊。。。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a><a href="#Code" title="Code"></a>Code</h4><pre><code>#include&lt;algorithm&gt;#include&lt;cstdio&gt;#define MAXN 100001using namespace std;int s[MAXN],n,m,tot,t,sum,ans[MAXN];struct data{int x,k,t,o,z,belong;}q[MAXN*2],tmp[MAXN*2];int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) x=x*10+ch-48,ch=getchar();    return x*f;}bool cmp(const data &amp;x,const data &amp;y){    if(x.x!=y.x) return x.x&lt;y.x;    else return x.k&lt;y.k;}void slove(int l,int r){    if(l==r) return ;    int mid=(l+r)&gt;&gt;1,ll=l,rr=mid+1;    for(int i=l;i&lt;=r;i++)    {        if(q[i].k==1&amp;&amp;q[i].t&lt;=mid) sum+=q[i].z;        else if(q[i].k==2&amp;&amp;q[i].t&gt;mid) ans[q[i].belong]+=sum*q[i].z;    }    for(int i=l;i&lt;=r;i++)    {        if(q[i].t&lt;=mid) tmp[ll++]=q[i];        else tmp[rr++]=q[i];    }    sum=0;    for(int i=l;i&lt;=r;i++) q[i]=tmp[i];    slove(l,mid),slove(mid+1,r);    return ;}int main(){    int x,y,z;    n=read();    for(int i=1;i&lt;=n;i++) x=read(),q[++tot].x=i,q[tot].k=1,q[tot].z=x,q[tot].t=tot;    m=read();    for(int i=1;i&lt;=m;i++)    {        z=read(),x=read(),y=read();        if(z&amp;1)  q[++tot].x=x,q[tot].k=1,q[tot].z=y,q[tot].t=tot;        else        {            q[++tot].x=x-1,q[tot].k=2,q[tot].z=-1,q[tot].t=tot,q[tot].belong=++t;            q[++tot].x=y,q[tot].k=2,q[tot].z=1,q[tot].t=tot,q[tot].belong=t;        }    }    sort(q+1,q+tot+1,cmp);    slove(1,tot);    for(int i=1;i&lt;=t;i++) printf(&quot;%d\n&quot;,ans[i]);    return 0;}</code></pre><h3 id="Bzoj-2683-简单题"><a href="#Bzoj-2683-简单题" class="headerlink" title="Bzoj 2683: 简单题"></a><a href="#Bzoj-2683-简单题" title="Bzoj 2683: 简单题"></a>Bzoj 2683: 简单题</h3><p><strong>Time Limit: 50 Sec Memory Limit: 20M.</strong></p><p>Description</p><p>你有一个N*N的棋盘，每个格子内有一个整数，初始时的时候全部为0</p><p>两种操作：</p><p>1 x y A<br>1&lt;=x,y&lt;=N，A是正整数 将格子x,y里的数字加上A</p><p>2 x1 y1 x2 y2</p><p>输出x1 y1 x2 y2这个矩形内的数字和</p><p>1&lt;=N&lt;=500000,操作数不超过200000个，内存限制20M。</p><p>这道题是CDQ分治的模板题。</p><p>如果没有20MB的内存限制的话我们显然可以用二维树状数组或者二维线段树（鬼畜）维护。</p><p>如果强制在线的话我们可以用KD-tree去做(蒟蒻并不会)</p><p>CDQ分治做法:</p><p>我们发现时间，x坐标，y坐标这三个东西的都是有严格顺序要求的。</p><p>然后我们考虑怎么去简化问题。</p><p>我们先把操作离线，</p><p>把一个区间询问拆成4个简单的前缀询问，</p><p>然后对于修改和询问操作分别标记。</p><p>这样以后对x坐标进行排序。</p><p>这样就变成了在时间和y坐标限制下的简化问题</p><p>然后我们对于时间进行分治，要注意分治过程中操作时间的顺序的不能乱的。<br>在分治过程中，我们可以计算出前一半操作区间中的修改操作对后一半操作区间的询问操作的答案贡献，也就是后一半区间每一个询问操作的答案贡献的一部分。</p><p>那关于y坐标怎么搞？</p><p>我们可以用一维数据结构来维护它。</p><p>我们可以直接维护y坐标所在的这一行的答案贡献。</p><p>因为我们已经事先已经保证x坐标升序，这样当我们处理到x坐标所在列的时候，我们发现它前面的列的贡献我们不需要再维护了，因为我们不会再次查询x前面的列数了</p><p>这样我们可以直接维护一个矩形的前缀贡献,用树状数组或者线段树维护就好了。</p><pre class=" language-cpp"><code class="language-cpp">    <span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span>    <span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span>    <span class="token macro property">#<span class="token directive keyword">define</span> MAXN 500001</span>    <span class="token macro property">#<span class="token directive keyword">define</span> MAXM 200001</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>s<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span>tot<span class="token punctuation">,</span>ans<span class="token punctuation">[</span>MAXM<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> data<span class="token punctuation">{</span><span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>t<span class="token punctuation">,</span>o<span class="token punctuation">,</span>p<span class="token punctuation">,</span>be<span class="token punctuation">;</span><span class="token punctuation">}</span>q<span class="token punctuation">[</span>MAXM<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>tmp<span class="token punctuation">[</span>MAXM<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>f<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">char</span> ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>ch<span class="token operator">&lt;</span><span class="token string">'0'</span><span class="token operator">||</span>ch<span class="token operator">></span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span>f<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>ch<span class="token operator">>=</span><span class="token string">'0'</span><span class="token operator">&amp;&amp;</span>ch<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">)</span> x<span class="token operator">=</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>ch<span class="token number">-48</span><span class="token punctuation">,</span>ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token operator">*</span>f<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> z<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span> s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>z<span class="token punctuation">,</span>x<span class="token operator">+</span><span class="token operator">=</span>x<span class="token operator">&amp;</span><span class="token operator">-</span>x<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">getsum</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> sum<span class="token operator">+</span><span class="token operator">=</span>s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token operator">-</span><span class="token operator">=</span>x<span class="token operator">&amp;</span><span class="token operator">-</span>x<span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> data <span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token keyword">const</span> data <span class="token operator">&amp;</span>y<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>x<span class="token operator">==</span>y<span class="token punctuation">.</span>x<span class="token operator">&amp;&amp;</span>x<span class="token punctuation">.</span>y<span class="token operator">==</span>y<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span>p<span class="token operator">&lt;</span>y<span class="token punctuation">.</span>p<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>x<span class="token operator">==</span>y<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span>y<span class="token operator">&lt;</span>y<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>x<span class="token operator">&lt;</span>y<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">slove</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token operator">&lt;=</span>mid<span class="token operator">&amp;&amp;</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token operator">></span>mid<span class="token operator">&amp;&amp;</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> ans<span class="token punctuation">[</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>be<span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span><span class="token function">getsum</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token operator">*</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>o<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token operator">&lt;=</span>mid<span class="token operator">&amp;&amp;</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span><span class="token operator">-</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ll<span class="token operator">=</span>l<span class="token punctuation">,</span>rr<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>ll<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> tmp<span class="token punctuation">[</span>rr<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">slove</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">slove</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        n<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> z<span class="token punctuation">,</span>x1<span class="token punctuation">,</span>y1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span>y2<span class="token punctuation">,</span>k<span class="token punctuation">,</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            z<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>z<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                x1<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>y1<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                q<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token operator">=</span>x1<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token operator">=</span>y1<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>o<span class="token operator">=</span>k<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token operator">=</span>tot<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>z<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                x1<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>y1<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x2<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>y2<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                q<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token operator">=</span>x1<span class="token number">-1</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token operator">=</span>y1<span class="token number">-1</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>o<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token operator">=</span>tot<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>be<span class="token operator">=</span><span class="token operator">++</span>t<span class="token punctuation">;</span>                q<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token operator">=</span>x1<span class="token number">-1</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token operator">=</span>y2<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>o<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token operator">=</span>tot<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>be<span class="token operator">=</span>t<span class="token punctuation">;</span>                q<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token operator">=</span>x2<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token operator">=</span>y1<span class="token number">-1</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>o<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token operator">=</span>tot<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>be<span class="token operator">=</span>t<span class="token punctuation">;</span>                q<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token operator">=</span>x2<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token operator">=</span>y2<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>o<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token operator">=</span>tot<span class="token punctuation">,</span>q<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>be<span class="token operator">=</span>t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">sort</span><span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>q<span class="token operator">+</span>tot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">slove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>tot<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>t<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><a href="#参考文献" title="参考文献"></a>参考文献</h2><p>许昊然 2013年国家集训队论文《浅谈数据结构题的几个非经典题非经典算法》</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化数据结构学习笔记</title>
      <link href="/2020/05/19/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/19/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>高中时的笔记，重新发布一下qwq。</p><h1 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a><a href="#可持久化数据结构" title="可持久化数据结构"></a>可持久化数据结构</h1><p>What:一种可以保留历史版本的数据结构。</p><p>一个具有持久化能力的数据结构在其被修改后可以保存当前的状态，从本质上来说，这样的数据结构是不可改变类型</p><p>可持久化数据结构(Persistent data structure)就是利用函数式编程的思想使其支持询问历史版本、同时充分利用它们之间的共同数据来减少时间和空间消耗。</p><p>包括可持久化线段树，可持久化字典树，可持久化平衡树，可持久化链表，<br>可持久化并查集等</p><h2 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a><a href="#可持久化线段树" title="可持久化线段树"></a>可持久化线段树</h2><p>可持久化线段树又称<strong>主席树</strong>，函数式线段树。</p><blockquote><p>主席树就是利用函数式编程的思想来使线段树支持询问历史版本、同时充分利用它们之间的共同数据来减少时间和空间消耗的增强版的线段树。<br>很多问题如果用线段树处理的话需要采用离线思想，若用主席树则可直接在线处理。故很多时候离线线段树求解可以转化为在线主席树求解。注意，主席树本质就是线段树，变化就在其实现可持久化，后一刻可以参考前一刻的副本，二者共同部分很多。一颗线段树的节点维护的是当前节点对应区间的信息，倘若每次区间都不一样，就会给处理带来一些困难。有时可以直接细分区间然后合并，此种情况线段树可以直接敲定；但有时无法通过直接划分区间来求解，如频繁询问区间第k小元素。<br>主席树的每个节点对应一颗线段树，此处有点抽象。在我们的印象中，每个线段树的节点维护的树左右子树下标以及当前节点对应区间的信息（信息视具体问题定）。对于一个待处理的序列a[1]、a[2]…a[n]，有n个前缀。每个前缀可以看做一棵线段树，共有n课线段树；若不采用可持久化结构，带来的严重后果就是会MLE，即对内存来说很难承受。根据可持久化数据结构的定义，由于相邻线段树即前缀的公共部分很多，可以充分利用，达到优化目的，同时每棵线段树还是保留所有的叶节点只是较之前共用了很多共用节点。主席树很重要的操作就是如何寻找公用的节点信息，这些可能可能出现在根节点也可能出现在叶节点。</p><p>所谓主席树呢，就是对原来的数列[1..n]的每一个前缀[1..i]（1≤i≤n）建立一棵线段树，线段树的每一个节点存某个前缀[1..i]中属于区间[L..R]的数一共有多少个（比如根节点是[1..n]，一共i个数，sum[root] = i；根节点的左儿子是[1..(L+R)/2]，若不大于(L+R)/2的数有x个，那么sum[root.left] = x）。若要查找[i..j]中第k大数时，设某结点x，那么x.sum[j] - x.sum[i - 1]就是[i..j]中在结点x内的数字总数。而对每一个前缀都建一棵树，会MLE，观察到每个[1..i]和[1..i-1]只有一条路是不一样的，那么其他的结点只要用回前一棵树的结点即可，时空复杂度为O(nlogn)。</p><p>摘自<a href="here" title="http://blog.csdn.net/xiaofengcanyuexj/article/details/25553521?utm_source=tuicool&amp;utm_medium=referral">here</a></p></blockquote><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a><a href="#个人理解" title="个人理解"></a>个人理解</h3><p>主席树是维护一条链上的东西。</p><p>例如在序列上我们一般维护[1，i]这段序列区间，当我们需要维护[1,i+1]时，发现我们现在已经维护好了[1,i]，我们现在只需要修改一条链就好了，所以每个点都会有若干根节点到它的唯一一条路径，也就是说我们新建了LogN个节点，所以理论空间复杂度是NLogN的。</p><p>经典例题区间第k大：</p><p>先考虑只有一次询问的情况：我们可以先统计出每个数出现的次数，然后二分答案。</p><p>那么多次询问呢?我们还是采用同样的思路，离散化后建立n棵权值线段树分别维护[1.i]的这个东西，在某个值的data域+1，然后对出现次数做一个前缀和，我们就可以表示[1,p]这个权值区间的答案贡献了，然后发现这个东西是可以直接相减的，用[1,y+1]减去[1,x-1]的贡献就是答案。</p><p>什么？n棵线段树？当然不需要，我们只需要对这些线段树可持久化就可以了。</p><p>主席树的第i棵树维护的是[1,i]这段区间的权值贡献，权值贡献用区间和来维护。</p><p>root[i]表示维护区间[1,i]的树的根节点是谁，当我们找到root[i]的时候，也就相当于我们找到了这颗树。</p><p>我们会发现在这里面只有叶子节点存储了信息，非叶子节点只是维护了一些东西。</p><p>主席树的标记下放，我们目的是要保留历史版本，所以不能在原来的节点上直接修改，所以我们考虑新建节点，然后建立关系.</p><p>扩展：主席树维护树上第k大：我们用类似序列的思路考虑这个问题，我们知道序列维护的是[1,i]的区间贡献，那树上呢？一个很正常的思路是维护i节点到根的区间贡献，因为这条路径是唯一的，我们在dfs的时候顺便维护它，那么显然答案就变成了ans[u]+ans[v]-ans[lca(u,v)]-ans[fa[lca(u,v)]]，查找的时候还是用二分的思想找。</p><h2 id="可持久化并查集"><a href="#可持久化并查集" class="headerlink" title="可持久化并查集"></a><a href="#可持久化并查集" title="可持久化并查集"></a>可持久化并查集</h2><p>用可持久化线段树（or 可持久化平衡树搞）</p><p>维护当前版本下集合的关系和秩的信息.</p><p>然后启发式合并(按秩合并)</p><p>合并的时候在权值线段树的子节点加一个数,</p><p>相当于连了一条边 表示有关系存在.</p><p>显然只有在两个集合秩相同时才更新秩.</p><p>……</p><h2 id="可持久化字典树"><a href="#可持久化字典树" class="headerlink" title="可持久化字典树"></a><a href="#可持久化字典树" title="可持久化字典树"></a>可持久化字典树</h2><p>（待填坑）</p><h2 id="可持久化平衡树"><a href="#可持久化平衡树" class="headerlink" title="可持久化平衡树"></a><a href="#可持久化平衡树" title="可持久化平衡树"></a>可持久化平衡树</h2><p>好像只有Treap 是可持久化的？然而我并不会orz。<br>（待填坑）</p><h2 id="可持久化链表"><a href="#可持久化链表" class="headerlink" title="可持久化链表"></a><a href="#可持久化链表" title="可持久化链表"></a>可持久化链表</h2><p>（待填坑）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="#参考资料" title="参考资料"></a>参考资料</h2><p>《可持久化数据结构研究》 陈立杰</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splay学习笔记</title>
      <link href="/2020/05/19/Splay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/19/Splay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Splay学习笔记"><a href="#Splay学习笔记" class="headerlink" title="Splay学习笔记"></a>Splay学习笔记</h1><p>高中时的笔记，重新发布一下。<br>图好像都丢了，网上一堆，可以搜一下。</p><p><a href="#Splay" title="Splay"></a>Splay</p><h1 id="类别：二叉排序树"><a href="#类别：二叉排序树" class="headerlink" title="类别：二叉排序树"></a><a href="#类别：二叉排序树" title="类别：二叉排序树"></a>类别：二叉排序树</h1><p>空间复杂度：O(n)</p><p>时间复杂度：O(log n)内完成插入、查找、删除操作</p><p>创造者：Daniel Sleator和Robert Tarjan</p><p>优点：每次查询会调整树的结构，使被查询频率高的条目更靠近树根。</p><p>树的旋转是splay的基础，对于二叉查找树来说，树的旋转不破坏查找树的结构。</p><h2 id="Splaying"><a href="#Splaying" class="headerlink" title="Splaying"></a><a href="#Splaying" title="Splaying"></a>Splaying</h2><p>Splaying是Splay Tree中的基本操作，为了让被查询的条目更接近树根，Splay Tree使用了树的旋转操作，同时保证二叉排序树的性质不变。</p><p>Splaying的操作受以下三种因素影响：</p><p>节点x是父节点p的左孩子还是右孩子</p><p>节点p是不是根节点，如果不是</p><p>看节点p是父节点g的左孩子还是右孩子</p><p>同时有三种基本操作：</p><h3 id="Zig-Step"><a href="#Zig-Step" class="headerlink" title="Zig Step"></a><a href="#Zig-Step" title="Zig Step"></a>Zig Step</h3><p><img src="http://img.my.csdn.net/uploads/201210/10/1349877565_2986.png" alt="1" loading="lazy"></p><p>当p为根节点时，进行zip step操作。</p><p>当x是p的左孩子时，对x右旋；</p><p>当x是p的右孩子时，对x左旋。<br><img src="http://img.my.csdn.net/uploads/201210/10/1349877709_4105.png" alt loading="lazy"></p><h3 id="Zig-Zig-Step"><a href="#Zig-Zig-Step" class="headerlink" title="Zig-Zig Step"></a><a href="#Zig-Zig-Step" title="Zig-Zig Step"></a>Zig-Zig Step</h3><p><img src="http://img.my.csdn.net/uploads/201210/10/1349877744_7090.png" alt loading="lazy"></p><p>当p不是根节点，且x和p不同为左孩子或右孩子时，进行Zig-Zag操作。</p><p>当p为左孩子，x为右孩子时，将x左旋后再右旋。</p><p>当p为右孩子，x为左孩子时，将x右旋后再左旋。</p><h2 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a><a href="#Advantage" title="Advantage"></a>Advantage</h2><p>1.可靠的性能——它的平均效率不输于其他平衡树。</p><p>2.存储所需的内存少——伸展树无需记录额外的什么值来维护树的信息，相对于其他平衡树，内存占用要小。</p><p>3.支持可持久化——可以将其改造成可持久化伸展树。可持久化数据结构允许查询修改之前数据结构的信息，对于一般的数据结构，每次操作都有可能移除一些信息，而可持久化的数据结构允许在任何时间查询到之前某个版本的信息。可持久化这一特性在函数式编程当中非常有用。另外，可持久化伸展树每次一般操作的均摊复杂度是O(log n)</p><pre><code>                             摘自Wikipedia</code></pre><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a><a href="#个人理解" title="个人理解"></a>个人理解</h2><p>splay是平衡树中一种比较简单易懂的数据结构。</p><p>各种操作均摊复杂度都是LogN的</p><p>旋转总结起来就是：共线转孙子，不共线转儿子。</p><p>我们的目的就是为了使任意时刻树的深度尽量低以保证复杂度。</p><p>splay的区间操作比较有意思。</p><p>比如我们要对序列区间[x,y]搞一些事情，我们可以先把x-1转到root，然后把y+1转到root的儿子</p><p>然后我们要求的区间[x,y]就是y+1的左子树了。</p><p>貌似所有的区间操作都基于这个东西。</p><p>splay 还可以维护GSS之类的东西。</p><p>splay是动态树（LCT）的基础（这些东西都是tarjan等人发明的 在此致以崇高的敬意orz）。</p><p>splay的启发式合并姿势是暴力重构节点数小的那一棵，但是复杂度还是很可观的Nlog2N.</p><p>貌似有个东西叫 finger search 合并可以降到NlogN(但是国内没找到相关论文)</p><p>splay调试复杂度较高，个人感觉基本的错误在于splaying，Tag的传递还有虚拟点的设置。</p><p>(未完待续)</p><p><a href="#Code们" title="Code们"></a>Code们</p><pre class=" language-cpp"><code class="language-cpp">    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//旋转</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> y<span class="token operator">=</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>z<span class="token operator">=</span>fa<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token punctuation">)</span> l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> l<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>r<span class="token operator">=</span>l<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">==</span>k<span class="token punctuation">)</span> k<span class="token operator">=</span>x<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span>y<span class="token punctuation">)</span> tree<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拆. </span>            <span class="token keyword">else</span> tree<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>z<span class="token punctuation">,</span>fa<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>fa<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>tree<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">splay</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//splaying</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> y<span class="token punctuation">,</span>z<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>k<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            y<span class="token operator">=</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>z<span class="token operator">=</span>fa<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">!=</span>k<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token punctuation">)</span><span class="token operator">^</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">rotate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//共线旋转孙子. </span>                <span class="token keyword">else</span> <span class="token function">rotate</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不共线旋转儿子. </span>            <span class="token punctuation">}</span>            <span class="token function">rotate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>k<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> f<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//加入元素. </span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>size<span class="token operator">++</span><span class="token punctuation">;</span>k<span class="token operator">=</span>size<span class="token punctuation">;</span>num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>fa<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">;</span><span class="token function">splay</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span>num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//维护二叉树性质.</span>        <span class="token keyword">else</span> <span class="token function">add</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//查找前驱.</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;=</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>t1<span class="token operator">=</span>num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>x1<span class="token operator">=</span>k<span class="token punctuation">;</span><span class="token function">before</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token function">before</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//查找后继.</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">>=</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>t2<span class="token operator">=</span>num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>x2<span class="token operator">=</span>k<span class="token punctuation">;</span><span class="token function">after</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token function">after</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//区间翻转</span>    <span class="token punctuation">{</span>        t1<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span>t2<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">splay</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">splay</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span>tree<span class="token punctuation">[</span>t1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rev<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>t2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">^</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sloveadd</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//在x后面添加y个元素(暴力添加最后维护BST性质)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> k<span class="token punctuation">;</span>        t1<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span>t2<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">splay</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">splay</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span>tree<span class="token punctuation">[</span>t2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        k<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>t1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">++</span>tot<span class="token punctuation">;</span>fa<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>t1<span class="token punctuation">;</span>s<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">,</span>size<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">,</span>max1<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>maxl<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>maxr<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>total<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            k<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fa<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>tot<span class="token number">-1</span><span class="token punctuation">;</span>tree<span class="token punctuation">[</span>tot<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>tot<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">,</span>sum<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>max1<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>maxl<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>maxr<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">splay</span><span class="token punctuation">(</span>tot<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">slovequerysum</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//区间求和</span>    <span class="token punctuation">{</span>        t1<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span>t2<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">splay</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">splay</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span>tree<span class="token punctuation">[</span>t1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>sum<span class="token punctuation">[</span>tree<span class="token punctuation">[</span>t2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">slovedelete</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//区间删除</span>    <span class="token punctuation">{</span>        t1<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span>t2<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">splay</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">splay</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span>tree<span class="token punctuation">[</span>t1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>t2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">splay</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">slovechange</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> z<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//区间修改</span>    <span class="token punctuation">{</span>        t1<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span>t2<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">splay</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">splay</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span>tree<span class="token punctuation">[</span>t1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> k<span class="token operator">=</span>tree<span class="token punctuation">[</span>t2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        tag<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>z<span class="token punctuation">;</span>s<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>z<span class="token punctuation">;</span>sum<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>z<span class="token operator">*</span>size<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">splay</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络</title>
      <link href="/2020/05/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/05/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p><img src="https://bkimg.cdn.bcebos.com/pic/5366d0160924ab1803d0ea3038fae6cd7a890bf6?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="神经网络" loading="lazy"></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>典型的人工神经网络具有以下三个部分：</p><p><strong>结构</strong>（Architecture）结构指定了网络中的变量和它们的拓扑关系。例如，神经网络中的变量可以是神经元连接的权重（weights）和神经元的激励值（activities of the neurons）。<br><strong>激励函数</strong>（Activation Rule）大部分神经网络模型具有一个短时间尺度的动力学规则，来定义神经元如何根据其他神经元的活动来改变自己的激励值。一般激励函数依赖于网络中的权重（即该网络的参数）。<br><strong>学习规则</strong>（Learning Rule）学习规则指定了网络中的权重如何随着时间推进而调整。这一般被看做是一种长时间尺度的动力学规则。一般情况下，学习规则依赖于神经元的激励值。它也可能依赖于监督者提供的目标值和当前权重的值。例如，用于手写识别的一个神经网络，有一组输入神经元。输入神经元会被输入图像的数据所激发。在激励值被加权并通过一个函数（由网络的设计者确定）后，这些神经元的激励值被传递到其他神经元。这个过程不断重复，直到输出神经元被激发。最后，输出神经元的激励值决定了识别出来的是哪个字母。<br>                        ——–<a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C#%E5%88%86%E7%B1%BB" target="_blank" rel="noopener">Wikipedia</a></p><h2 id="激活函数-Activation-Rule"><a href="#激活函数-Activation-Rule" class="headerlink" title="激活函数(Activation Rule)"></a>激活函数(Activation Rule)</h2><p>激活函数的一般性质:<br>可微，非线性，计算简单，单调，输出值有一定范围，归一化。</p><p>归一化：把数据映射到(0,1)范围内处理。</p><p>主要有三种：<br>Sigmoid 函数,Tanh 函数(双曲正切),Relu函数</p><h3 id="Sigmoid-函数"><a href="#Sigmoid-函数" class="headerlink" title="Sigmoid 函数"></a>Sigmoid 函数</h3><p>表达式为<br><img src="/2020/05/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/sigmoid.png" alt="Sigmoid" loading="lazy"></p><p>它长这样<br><img src="https://bkimg.cdn.bcebos.com/pic/d009b3de9c82d158dfb4e7218a0a19d8bc3e426f?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_1,yp_1" alt="xxx" loading="lazy"></p><p>一些性质：类似于生物学上的S型函数，关于(0,0.5)中心对称，两边过于平坦，处处可微。值域(0,1)。在边界处于饱和状态。</p><p>缺点：会有梯度弥散。不根据原点对称。计算耗时大。</p><p>梯度弥散：使用反向传播算法传播梯度的时候,随着传播深度的增加,梯度的幅度会急剧减小,会导致浅层神经元的权重更新非常缓慢,不能有效学习。</p><h3 id="Tanh-函数"><a href="#Tanh-函数" class="headerlink" title="Tanh 函数"></a>Tanh 函数</h3><p><img src="/2020/05/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/tanh.png" alt="Tanh" loading="lazy"></p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587027878949&di=784457b00c9c6dfa44d34630a086a75d&imgtype=0&src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-eec4407568e4260a50cb01aad2cdb24d_b.jpg" alt="xx" loading="lazy"></p><p>一些性质：关于(0,0)中心对称，两边平滑。</p><p>优点：相对于前者，关于原点对称，计算较快。<br>缺点：仍未改变梯度弥散问题。</p><h3 id="Relu-函数"><a href="#Relu-函数" class="headerlink" title="Relu 函数"></a>Relu 函数</h3><img src="/2020/05/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/relu.png" class title="This is an example image" loading="lazy"><p><img src="/2020/05/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/relu.png" alt="Relu" loading="lazy"></p><p>单侧抑制，有一个阈值，超过了这个阈值就激活，小于阈值就是0。小于阈值的话不可导。计算更快，稀疏激活性更大（导数再正值区为常数，负值区为0。）<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587027901095&di=5c21df48cfda6cb0bb64a2c7a1b2299c&imgtype=0&src=http%3A%2F%2Fc.biancheng.net%2Fuploads%2Fallimg%2F190108%2F2-1Z10QA3035F.gif" alt="x" loading="lazy"></p><p>优缺点：解决了部分梯度弥散问题，收敛速度更快。但仍未完全解决梯度弥散问题，然后在负区神经元die且不可复活。<br>由于反向传播等问题，升级了Relu函数。</p><h3 id="leaky-Relu-函数"><a href="#leaky-Relu-函数" class="headerlink" title="leaky Relu 函数"></a>leaky Relu 函数</h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587033371072&di=2e81413bef5018c5358bc7486b8e135a&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20171103%2Fb9f1d55cf7914583ad66ca5bec01f9e1.png" alt="leaky Relu" loading="lazy"></p><p>解决了神经元die的问题。</p><p>(未完待续)</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分类算法</title>
      <link href="/2020/04/02/Classification/"/>
      <url>/2020/04/02/Classification/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前记录在OneNote上的，无法直接转成MD，现整理成pdf文档，发布在这里。</p><center>**分类算法**</center><br><div class="row">    <embed src="/pdf/分类算法.pdf" width="100%" height="550" type="application/pdf"></div> <br>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习笔记</title>
      <link href="/2020/03/30/Numpy/"/>
      <url>/2020/03/30/Numpy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前从网上学的，当时记录在了OneNote上，现整理成Markdown文档，发布在这里。</p><h2 id="一-Ndarray-对象"><a href="#一-Ndarray-对象" class="headerlink" title="一.Ndarray 对象"></a>一.Ndarray 对象</h2><h3 id="是啥？"><a href="#是啥？" class="headerlink" title="是啥？"></a><strong>是啥？</strong></h3><p>一个N维的数组对象。 存放同类型多元素的多维数组。</p><h3 id="组成："><a href="#组成：" class="headerlink" title="组成："></a><strong>组成</strong>：</h3><p>一个指向数据的指针。<br>数据类型（dtype） 描述在数组中的固定大小值的格子。<br>一个表示数组形状的元组，表示各维度大小的元组。<br>一个跨度元组，里边有一个整数指的是为了前进到当前维度下一个元素需要跨过的字节数。</p><h3 id="创建方法是啥？"><a href="#创建方法是啥？" class="headerlink" title="创建方法是啥？"></a><strong>创建方法是啥</strong>？</h3><p>用Numpy里的array函数   </p><pre class=" language-python"><code class="language-python">numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span>object<span class="token punctuation">,</span> dtype <span class="token operator">=</span> None<span class="token punctuation">,</span> copy <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span> order <span class="token operator">=</span> None<span class="token punctuation">,</span> subok <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span> ndmin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre><pre><code>参数说明名称             描述  * object    数组或嵌套的数列  * dtype           数组元素的数据类型(可选) 可以是复数，可以是结构体名  * copy        对象是否需要复制(可选)  * order        创建数组的样式，C 为行方向，F 为列方向，A 为任意方向（默认）  * subok        默认返回一个与基类类型一致的数组* ndmin        指定生成数组的最小维度</code></pre><h2 id="二-NumPy-数据类型"><a href="#二-NumPy-数据类型" class="headerlink" title="二.NumPy 数据类型"></a>二.NumPy 数据类型</h2><p>包含的数据类型非常多  </p><pre><code>名称        描述  * bool_        布尔型数据类型（True 或者 False）  * int_        默认的整数类型（类似于 C 语言中的 * long，int32 或 int64）  * intc        与 C 的 int 类型一样，一般是 int32 或 int 64  * intp        用于索引的整数类型（类似于 C 的   ssize_t，一般情况下仍然是 int32 或 int64）* int8        字节（-128 to 127）  * int16        整数（-32768 to 32767）  * int32        整数（-2147483648 to 2147483647）* int64        整数（-9223372036854775808 to 9223372036854775807）  * uint8        无符号整数（0 to 255）  * uint16    无符号整数（0 to 65535）  * uint32    无符号整数（0 to 4294967295）  * uint64    无符号整数（0 to 18446744073709551615）  * float_    float64 类型的简写  * float16    半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位  * float32    单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位  * float64    双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位  * complex_    complex128 类型的简写，即 128 位复数  * complex64    复数，表示双 32 位浮点数（实数部分和虚数部分）  * complex128复数，表示双 64 位浮点数（实数部分和虚数部分）</code></pre><h3 id="数据类型对象"><a href="#数据类型对象" class="headerlink" title="数据类型对象"></a>数据类型对象</h3><p>dtype 对象是使用以下语法构造的：   </p><pre class=" language-python"><code class="language-python">numpy<span class="token punctuation">.</span>dtype<span class="token punctuation">(</span>object<span class="token punctuation">,</span> align<span class="token punctuation">,</span> copy<span class="token punctuation">)</span></code></pre><pre><code>object - 要转换为的数据类型对象align - 如果为 true，填充字段使其类似 C 的结构体。copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</code></pre><p>其中每个内建类型都有一个唯一定义它的<strong>字符代码</strong>，如下：</p><pre><code>字符    对应类型  b        布尔型  i        (有符号) 整型  u        无符号整型 integer  f        浮点型  c        复数浮点型  m        timedelta（时间间隔）  M        datetime（日期时间）  O        (Python) 对象  S,a        (byte-)字符串  U        Unicode  V        原始数据 (void)  </code></pre><h2 id="三-Numpy-数组属性"><a href="#三-Numpy-数组属性" class="headerlink" title="三.Numpy 数组属性"></a>三.Numpy 数组属性</h2><h3 id="NumPy数组的一些基本属性"><a href="#NumPy数组的一些基本属性" class="headerlink" title="NumPy数组的一些基本属性"></a>NumPy数组的一些基本属性</h3><p><strong>数组的维数称为秩，秩也就是轴的数量。</strong><br><strong>每一个线性的数组称为轴(axis)，即维度。</strong> 例如每个二维数组是由一维个一维数组组成的，这里边有两个轴。（很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。）</p><p>NumPy 的数组中比较重要 ndarray 对象属性有：  </p><pre><code>属性                    说明  ndarray.ndim    秩，即轴的数量或维度的数量  ndarray.shape    数组的维度，对于矩阵，n 行 m 列  ndarray.size    数组元素的总个数，相当于 .shape 中 n*m 的值  ndarray.dtype    ndarray 对象的元素类型  ndarray.itemsize    ndarray 对象中每个元素的大小，以字节为单位  ndarray.flags    ndarray 对象的内存信息  ndarray.real    ndarray元素的实部  ndarray.imag    ndarray 元素的虚部  ndarray.data    包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</code></pre><p><strong>常用的函数 reshape 调整数组大小</strong></p><h2 id="四-NumPy-创建数组"><a href="#四-NumPy-创建数组" class="headerlink" title="四.NumPy 创建数组"></a>四.NumPy 创建数组</h2><h3 id="numpy-empty-numpy-empty方法"><a href="#numpy-empty-numpy-empty方法" class="headerlink" title="numpy.empty numpy.empty方法"></a>numpy.empty numpy.empty方法</h3><p>用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：   </p><pre class=" language-python"><code class="language-python">numpy<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> dtype <span class="token operator">=</span> float<span class="token punctuation">,</span> order <span class="token operator">=</span> <span class="token string">'C'</span><span class="token punctuation">)</span>   </code></pre><pre><code>参数说明：  参数    描述  shape    数组形状  dtype    数据类型，可选  order    有&quot;C&quot;和&quot;F&quot;两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。  </code></pre><p><strong>未初始化，所以是随机值</strong></p><h3 id="numpy-zeros"><a href="#numpy-zeros" class="headerlink" title="numpy.zeros"></a>numpy.zeros</h3><p>创建指定大小的数组，数组元素以 0 来填充：</p><pre class=" language-py"><code class="language-py"> numpy.zeros(shape, dtype = float, order = 'C') </code></pre><p>参数含义同上。</p><h3 id="numpy-ones"><a href="#numpy-ones" class="headerlink" title="numpy.ones"></a>numpy.ones</h3><p>创建指定形状的数组，数组元素以 1 来填充：</p><pre class=" language-py"><code class="language-py">numpy.ones(shape, dtype = None, order = 'C') </code></pre><p>参数含义同上。</p><h2 id="五-NumPy-从已有的数组创建数组"><a href="#五-NumPy-从已有的数组创建数组" class="headerlink" title="五.NumPy 从已有的数组创建数组"></a>五.NumPy 从已有的数组创建数组</h2><h3 id="numpy-asarray"><a href="#numpy-asarray" class="headerlink" title="numpy.asarray"></a>numpy.asarray</h3><p>numpy.asarray 类似 numpy.array，但 numpy.asarray 参数只有三个，比 numpy.array 少两个。 </p><pre class=" language-py"><code class="language-py">numpy.asarray(a, dtype = None, order = None)</code></pre><pre><code>参数说明：参数        描述a        任意形式的输入参数，可以是列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组dtype    数据类型，可选order    可选，有&quot;C&quot;和&quot;F&quot;两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</code></pre><h3 id="numpy-frombuffer"><a href="#numpy-frombuffer" class="headerlink" title="numpy.frombuffer"></a>numpy.frombuffer</h3><p>numpy.frombuffer 用于实现动态数组。<br>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p><pre class=" language-py"><code class="language-py">numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></pre><p><strong>注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</strong>    </p><pre><code>参数说明：  参数    描述  buffer    可以是任意对象，会以流的形式读入。  dtype    返回数组的数据类型，可选  count    读取的数据数量，默认为-1，读取所有数据。  offset    读取的起始位置，默认为0。  </code></pre><p>numpy.fromiter</p><p>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。  </p><pre class=" language-py"><code class="language-py">numpy.fromiter(iterable, dtype, count=-1)</code></pre><pre><code>参数          描述  iterable    可迭代对象  dtype        返回数组的数据类型  count        读取的数据数量，默认为-1，读取所有数据</code></pre><h2 id="六-NumPy-从数值范围创建特殊数组"><a href="#六-NumPy-从数值范围创建特殊数组" class="headerlink" title="六.NumPy 从数值范围创建特殊数组"></a>六.NumPy 从数值范围创建特殊数组</h2><h3 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange"></a>numpy.arange</h3><p>numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象，函数格式如下：  </p><pre class=" language-py"><code class="language-py">numpy.arange(start, stop, step, dtype) </code></pre><p>根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。  </p><pre><code>参数说明：参数    描述start    起始值，默认为0stop    终止值（不包含）step    步长，默认为1dtype    返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</code></pre><p><strong>范围：[strat,stop)</strong></p><h3 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace"></a>numpy.linspace</h3><p>numpy.linspace 函数用于创建一个一维数组，数组是一个<strong>等差数列</strong>构成的，格式如下：  </p><pre class=" language-py"><code class="language-py">np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) </code></pre><pre><code>参数说明：  参数            描述  start        序列的起始值  stop        序列的终止值，如果endpoint为true，该值于数列中  num            要生成的等步长的样本数量，默认为50  endpoint    该值为 true 时，数列中中包含stop值，反之包含，默认是True。  retstep        如果为 True 时，生成的数组中会显示间距，反之不显示。  dtype        ndarray 的数据类型</code></pre><h3 id="numpy-logspace"><a href="#numpy-logspace" class="headerlink" title="numpy.logspace"></a>numpy.logspace</h3><p>numpy.logspace 函数用于创建一个于<strong>等比数列</strong>。  </p><p>格式如下： </p><pre class=" language-py"><code class="language-py">np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None) </code></pre><p>base 参数意思是取对数的时候 log 的下标。</p><pre><code>参数    描述  start    序列的起始值为：base  start  stop    序列的终止值为：base  stop。如果endpoint为true，该值包含于数列中  num    要生成的等步长的样本数量，默认为50  endpoint    该值为 true 时，数列中中包含stop值，反之不包含，默认是True。  base    对数 log 的底数，默认是10。  dtype    ndarray 的数据类型  创建了一个[base^start,base^stop) 的数组,数组个数为num</code></pre><h2 id="七-NumPy-切片和索引"><a href="#七-NumPy-切片和索引" class="headerlink" title="七.NumPy 切片和索引"></a>七.NumPy 切片和索引</h2><h3 id="slice-函数"><a href="#slice-函数" class="headerlink" title="slice 函数"></a>slice 函数</h3><p> 先创建一个数组</p><pre class=" language-py"><code class="language-py">a = np.arange(n) s = slice(start,stop,step) </code></pre><p> a[s]为切片后的结果 或者 s = a[start : stop : step]<br> 注：s为切片后的结果<br> start, stop 及 step 参数分别为 结果数组的三者 [start,stop)<br> 注 ： 若只有一个参数start，则返回一个该参数索引的元素。 切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 a[…,1] 是第二列 a[1,…] 是第二行 a[…,1:] 是从第二列开始以及以后的元素</p><p><strong>NumPy 高级索引 先略过吧…好像用处不大</strong></p><h2 id="八-NumPy-广播-Broadcast"><a href="#八-NumPy-广播-Broadcast" class="headerlink" title="八.NumPy 广播(Broadcast)"></a>八.NumPy 广播(Broadcast)</h2><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。<br>如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。<br>如果两个数组形状不同，触发广播机制  </p><pre><code>广播的规则:  让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。 输出数组的形状是输入数组形状的各个维度上的最大值。 如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。 当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。  </code></pre><p>简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足： 数组拥有相同形状。 当前维度的值相等。 当前维度的值有一个是 1。 若条件不满足，抛出 “ValueError: frames are not aligned” 异常。 tile() 函数，将原矩阵横向、纵向地复制。 Tile(s,a,b)  将原矩阵横向复制a倍，纵向b倍。 </p><h2 id="九-NumPy遍历数组"><a href="#九-NumPy遍历数组" class="headerlink" title="九.NumPy遍历数组"></a>九.NumPy遍历数组</h2><h3 id="numpy-nditer"><a href="#numpy-nditer" class="headerlink" title="numpy.nditer"></a>numpy.nditer</h3><p><strong>迭代器对象</strong> </p><pre class=" language-py"><code class="language-py">for x in np.nditer(a) : print(x) </code></pre><p>多维数组默认是行优先的，若使用列优先，则可将数组转置为a.t再强制使用行优先 因为a 和 a.T 的遍历顺序是一样的 for x in np.nditer(a, order=’F’): Fortran order，列序优先； for x in np.nditer(a.T, order=’C’): C order，行序优先；</p><p>修改数组中元素的值 可选参数 <strong>op_flags</strong><br> 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。</p><pre class=" language-py"><code class="language-py">np.nditer(a,op_flag = ['readwrite']) : </code></pre><h2 id="十-Numpy-数组操作"><a href="#十-Numpy-数组操作" class="headerlink" title="十.Numpy 数组操作"></a>十.Numpy 数组操作</h2><p>X[…] = new value</p><pre><code>相关函数函数    描述  reshape    不改变数据的条件下修改形状  flat    数组元素迭代器  flatten    返回一份数组拷贝，对拷贝所做的修改不会影响原始数组  ravel    返回展开数组</code></pre><h3 id="numpy-ndarray-flatten"><a href="#numpy-ndarray-flatten" class="headerlink" title="numpy.ndarray.flatten"></a>numpy.ndarray.flatten</h3><pre class=" language-py"><code class="language-py">ndarray.flatten(order='C') </code></pre><p>ndarray 是数组名<br>参数说明：<br>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</p><h3 id="numpy-ravel"><a href="#numpy-ravel" class="headerlink" title="numpy.ravel"></a>numpy.ravel</h3><pre class=" language-py"><code class="language-py">numpy.ravel(a, order='C')</code></pre><p> 将数组展成一维数组 参数同上</p><h3 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h3><pre><code>函数    描述transpose    对换数组的维度ndarray.T    和 self.transpose() 相同rollaxis    向后滚动指定的轴swapaxes    对换数组的两个轴</code></pre><h3 id="numpy-transpose"><a href="#numpy-transpose" class="headerlink" title="numpy.transpose"></a>numpy.transpose</h3><p>numpy.transpose 函数用于对换数组的维度，格式如下：  </p><pre class=" language-py"><code class="language-py">numpy.transpose(arr, axes) </code></pre><pre><code>参数说明:   arr：要操作的数组   axes(可选)：整数列表，对应维度，不选的话所有维度都会对换，所以二维就是转置。</code></pre><p>numpy.rollaxis 函数向后滚动特定的轴到一个特定位置，格式如下： </p><pre class=" language-py"><code class="language-py">numpy.rollaxis(arr, axis, start) </code></pre><pre><code>参数说明：   arr：    数组   axis：    要向后滚动的轴，其它轴的相对位置不会改变     start： 默认为零，表示完整的滚动。会滚动到特定位置。 目测用不到…且较难</code></pre><h3 id="numpy-swapaxes"><a href="#numpy-swapaxes" class="headerlink" title="numpy.swapaxes"></a>numpy.swapaxes</h3><p>函数用于交换数组的两个轴，格式如下： </p><pre class=" language-py"><code class="language-py">numpy.swapaxes(arr, axis1, axis2) </code></pre><pre><code>参数说明arr：    输入的数组   axis1：    对应第一个轴的整数  axis2：    对应第二个轴的整数 和上面那个类似</code></pre><p>修改数组维度<br>维度    描述<br>broadcast    产生模仿广播的对象<br>broadcast_to    将数组广播到新形状<br>expand_dims    扩展数组的形状<br>squeeze    从数组的形状中删除一维条目</p><h3 id="numpy-broadcast"><a href="#numpy-broadcast" class="headerlink" title="numpy.broadcast"></a>numpy.broadcast</h3><p>用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。 也可以手动广播</p><h3 id="numpy-broadcastto"><a href="#numpy-broadcastto" class="headerlink" title="numpy.broadcastto"></a>numpy.broadcastto</h3><pre class=" language-py"><code class="language-py">numpy.broadcast_to(array, shape, subok)</code></pre><p>函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 <strong>如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</strong> </p><h3 id="numpy-expanddims"><a href="#numpy-expanddims" class="headerlink" title="numpy.expanddims"></a>numpy.expanddims</h3><p>函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:   </p><pre class=" language-py"><code class="language-py">numpy.expand_dims(arr, axis)   </code></pre><pre><code>参数说明：  arr：输入的数组   axis：新轴插入的位置 插入了一个空轴</code></pre><h3 id="numpy-squeeze-numpy-squeeze"><a href="#numpy-squeeze-numpy-squeeze" class="headerlink" title="numpy.squeeze numpy.squeeze"></a>numpy.squeeze numpy.squeeze</h3><p>函数从给定数组的形状中删除一维的条目，函数格式如下：  </p><pre class=" language-py"><code class="language-py">numpy.squeeze(arr, axis) </code></pre><pre><code>参数说明：   arr：输入数组   axis：整数或整数元组，用于选择形状中一维条目的子集 和上面类似</code></pre><p>连接数组</p><pre><code>函数    描述  concatenate    连接沿现有轴的数组序列  stack    沿着新的轴加入一系列数组。  hstack    水平堆叠序列中的数组（列方向）  vstack    竖直堆叠序列中的数组（行方向）  </code></pre><h3 id="numpy-concatenate"><a href="#numpy-concatenate" class="headerlink" title="numpy.concatenate()"></a>numpy.concatenate()</h3><p>numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组，格式如下： </p><pre class=" language-py"><code class="language-py">numpy.concatenate((a1, a2, ...), axis) </code></pre><pre><code>参数说明：  a1, a2, ...：相同类型的数组 axis：沿着它连接数组的轴，默认为 0</code></pre><h3 id="numpy-stack"><a href="#numpy-stack" class="headerlink" title="numpy.stack()"></a>numpy.stack()</h3><p>numpy.stack 函数用于沿新轴连接数组序列，格式如下：</p><pre class=" language-py"><code class="language-py">numpy.stack(arrays, axis) </code></pre><pre><code>参数说明：  arrays 相同形状的一组数组序列，如(a,b)  axis：返回数组中的轴，输入数组沿着它来堆叠</code></pre><h3 id="numpy-hstack"><a href="#numpy-hstack" class="headerlink" title="numpy.hstack()"></a>numpy.hstack()</h3><p>numpy.hstack 是 numpy.stack 函数的变体，它通过水平堆叠来生成数组。 </p><pre class=" language-py"><code class="language-py">ans =  np.hstack((a,b))</code></pre><h3 id="numpy-vstack"><a href="#numpy-vstack" class="headerlink" title="numpy.vstack"></a>numpy.vstack</h3><p>同上 竖直堆叠</p><h3 id="分割数组"><a href="#分割数组" class="headerlink" title="分割数组"></a>分割数组</h3><pre><code>函数    数组及操作split    将一个数组分割为多个子数组hsplit    将一个数组水平分割为多个子数组（按列）vsplit    将一个数组垂直分割为多个子数组（按行）</code></pre><h3 id="numpy-split"><a href="#numpy-split" class="headerlink" title="numpy.split()"></a>numpy.split()</h3><p>numpy.split 函数沿特定的轴将数组分割为子数组，格式`如下： </p><pre class=" language-py"><code class="language-py">numpy.split(ary, indicesorsections, axis)</code></pre><pre><code>参数说明：   ary：    被分割的数组   indicesorsections：    如果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）   axis：    沿着哪个维度进行切向，默认为0，横向切分，也就是水平切分。为1时，纵向切分 numpy.hsplit 水平切分 numpy.vsplit 垂直切分</code></pre><h3 id="数组元素的添加与删除"><a href="#数组元素的添加与删除" class="headerlink" title="数组元素的添加与删除"></a>数组元素的添加与删除</h3><pre><code>函数    元素及描述resize    返回指定形状的新数组append    将值添加到数组末尾insert    沿指定轴将值插入到指定下标之前delete    删掉某个轴的子数组，并返回删除后的新数组unique    查找数组内的唯一元素</code></pre><h3 id="numpy-resize"><a href="#numpy-resize" class="headerlink" title="numpy.resize()"></a>numpy.resize()</h3><p>numpy.resize 函数返回指定大小的新数组。 如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p><pre class=" language-py"><code class="language-py">numpy.resize(arr, shape)  </code></pre><pre><code>参数说明：  arr：要修改大小的数组  shape：返回数组的新形状</code></pre><h3 id="numpy-append"><a href="#numpy-append" class="headerlink" title="numpy.append()"></a>numpy.append()</h3><p>numpy.append 函数在数组的末尾添加值。<br>追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。<br>append 函数返回的始终是一个一维数组。</p><pre class=" language-py"><code class="language-py">numpy.append(arr, values, axis=None) </code></pre><pre><code>参数说明： arr：输入数组  values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）  axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</code></pre><h3 id="numpy-insert"><a href="#numpy-insert" class="headerlink" title="numpy.insert()"></a>numpy.insert()</h3><p>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。 如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p><pre class=" language-py"><code class="language-py">numpy.insert(arr, obj, values, axis) </code></pre><pre><code>参数说明：  arr：输入数组  obj：在其之前插入值的索引  values：要插入的值  axis：沿着它插入的轴，如果未提供，则输入数组会被展开</code></pre><h3 id="numpy-delete"><a href="#numpy-delete" class="headerlink" title="numpy.delete()"></a>numpy.delete()</h3><p>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p><pre class=" language-py"><code class="language-py">numpy.delete(arr, obj, axis)  </code></pre><pre><code>参数说明：arr：    输入数组  obj：    可以被切片，整数或者整数数组，表明要从输入数组删除的子数组  axis：    沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</code></pre><h3 id="numpy-unique"><a href="#numpy-unique" class="headerlink" title="numpy.unique()"></a>numpy.unique()</h3><p>numpy.unique 函数用于去除数组中的重复元素。 </p><pre class=" language-py"><code class="language-py">numpy.unique(arr, returnindex, returninverse, returncounts) </code></pre><pre><code>参数说明  arr：            输入数组，如果不是一维数组则会展开 returnindex：    如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储存  returninverse：    如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储存   returncounts：    如果为true，返回去重数组中的元素在原数组中的出现次数</code></pre><h2 id="十一-NumPy-位运算"><a href="#十一-NumPy-位运算" class="headerlink" title="十一.NumPy 位运算"></a>十一.NumPy 位运算</h2><p><strong>NumPy “bitwise_” 开头的函数是位运算函数。</strong>  </p><p>NumPy 位运算包括以下几个函数：</p><pre><code>函数        描述  bitwise_and    对数组元素执行位与操作  bitwise_or    对数组元素执行位或操作  invert        按位取反  left_shift    向左移动二进制表示的位  right_shift    向右移动二进制表示的位</code></pre><p><strong>bin(a)</strong>  a的二进制 前两个函数顾名思义，对(a,b)做相应操作</p><h3 id="invert"><a href="#invert" class="headerlink" title="invert"></a>invert</h3><p>invert() 函数对数组中整数进行按位取反运算，即 0 变成 1，1 变成 0。 对于有符号整数，取该二进制数的补码，然后 +1。二进制数，最高位为0表示正数，最高位为 1 表示负数。</p><p>左右移就是 <strong>right_shift(a,b)</strong> 将a移动b位，全都补0</p><h2 id="十二-NumPy-字符串函数"><a href="#十二-NumPy-字符串函数" class="headerlink" title="十二.NumPy 字符串函数"></a>十二.NumPy 字符串函数</h2><p>以下函数用于对 dtype 为 numpy.string 或 numpy.unicode 的数组执行向量化字符串操作。 它们基于 Python 内置库中的标准字符串函数。</p><p>这些函数在字符数组类（numpy.char）中定义。</p><pre><code>函数                    描述add()            对两个数组的逐个字符串元素进行连接multiply()        返回按元素多重连接后的字符串center()        居中字符串capitalize()    将字符串第一个字母转换为大写title()            将字符串的每个单词的第一个字母转换为大写lower()            数组元素转换为小写upper()            数组元素转换为大写split()            指定分隔符对字符串进行分割，并返回数组列表splitlines()    返回元素中的行列表，以换行符分割strip()            移除元素开头或者结尾处的特定字符join()            通过指定分隔符来连接数组中的元素replace()        使用新字符串替换字符串中的所有子字符串decode()        数组元素依次调用str.decodeencode()        数组元素依次调用str.encode(编码默认utf-8)</code></pre><h2 id="十三-NumPy-数学函数"><a href="#十三-NumPy-数学函数" class="headerlink" title="十三.NumPy 数学函数"></a>十三.NumPy 数学函数</h2><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>NumPy 提供了标准的三角函数：<strong>sin()</strong>、<strong>cos()</strong>、<strong>tan()</strong>。 也有相应的反三角函数。<br>np.pi 就是pi</p><h3 id="舍入函数"><a href="#舍入函数" class="headerlink" title="舍入函数"></a>舍入函数</h3><p>numpy.around() 函数返回指定数字的四舍五入值。 </p><pre class=" language-py"><code class="language-py">numpy.around(a,decimals)  </code></pre><pre><code>参数说明：  a: 数组  decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</code></pre><h3 id="numpy-floor"><a href="#numpy-floor" class="headerlink" title="numpy.floor()"></a>numpy.floor()</h3><p>numpy.floor() 返回小于或者等于指定表达式的最大整数，即向下取整。</p><h3 id="numpy-ceil"><a href="#numpy-ceil" class="headerlink" title="numpy.ceil()"></a>numpy.ceil()</h3><p>numpy.ceil() 返回大于或者等于指定表达式的最小整数，即向上取整。</p><h2 id="十四-NumPy-算术函数"><a href="#十四-NumPy-算术函数" class="headerlink" title="十四.NumPy 算术函数"></a>十四.NumPy 算术函数</h2><p>NumPy 算术函数包含简单的加减乘除: <strong>add()</strong>，<strong>subtract()</strong>，<strong>multiply()</strong> 和 <strong>divide()</strong>。 需要注意的是数组必须具有相同的形状或符合数组广播规则。</p><p><strong>一些有意思的函数</strong></p><h3 id="numpy-reciprocal"><a href="#numpy-reciprocal" class="headerlink" title="numpy.reciprocal()"></a>numpy.reciprocal()</h3><p>numpy.reciprocal()  函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。</p><h3 id="numpy-power"><a href="#numpy-power" class="headerlink" title="numpy.power()"></a>numpy.power()</h3><p>numpy.power()  函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><h3 id="numpy-mod"><a href="#numpy-mod" class="headerlink" title="numpy.mod()"></a>numpy.mod()</h3><p>numpy.mod() 计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder() 也产生相同的结果。分别对每个元素取模，ai%bi</p><h2 id="十五-NumPy-统计函数"><a href="#十五-NumPy-统计函数" class="headerlink" title="十五.NumPy 统计函数"></a>十五.NumPy 统计函数</h2><h3 id="numpy-amin-和-numpy-amax"><a href="#numpy-amin-和-numpy-amax" class="headerlink" title="numpy.amin() 和 numpy.amax()"></a>numpy.amin() 和 numpy.amax()</h3><p>numpy.amin() 用于计算数组中的元素沿指定轴的最小值。<br>numpy.amax() 用于计算数组中的元素沿指定轴的最大值。</p><h3 id="numpy-ptp"><a href="#numpy-ptp" class="headerlink" title="numpy.ptp()"></a>numpy.ptp()</h3><p>numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）</p><h3 id="numpy-percentile"><a href="#numpy-percentile" class="headerlink" title="numpy.percentile()"></a>numpy.percentile()</h3><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 </p><pre class=" language-py"><code class="language-py">numpy.percentile(a, q, axis) </code></pre><p>函数numpy.percentile()接受以下参数。 </p><pre><code>参数说明：a: 输入数组q: 要计算的百分位数，在 0 ~ 100 之间axis: 沿着它计算百分位数的轴</code></pre><h3 id="numpy-median"><a href="#numpy-median" class="headerlink" title="numpy.median()"></a>numpy.median()</h3><p>numpy.median() 函数用于计算数组 a 中元素的中位数（中值）</p><h3 id="numpy-mean"><a href="#numpy-mean" class="headerlink" title="numpy.mean()"></a>numpy.mean()</h3><p>numpy.mean() 函数返回数组中元素的算术平均值。<br>如果提供了轴，则沿其计算。<br>要给定轴 算术平均值是沿轴的元素的总和除以元素的数量。</p><h3 id="numpy-average"><a href="#numpy-average" class="headerlink" title="numpy.average()"></a>numpy.average()</h3><p>numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。 不指定权重时相当于mean函数 该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。 加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h3><p>标准差是一组数据平均值分散程度的一种度量。 标准差是方差的算术平方根。 标准差公式如下： 使用时直接调用std函数即可 </p><pre class=" language-py"><code class="language-py">std = sqrt(mean((x - x.mean())2))</code></pre><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 </p><pre class=" language-py"><code class="language-py">var=mean((x - x.mean()) 2)。 </code></pre><p>换句话说，标准差是方差的平方根。 使用时直接调用var函数即可</p><h2 id="十六-NumPy-排序、条件刷选函数"><a href="#十六-NumPy-排序、条件刷选函数" class="headerlink" title="十六.NumPy 排序、条件刷选函数"></a>十六.NumPy 排序、条件刷选函数</h2><p>提供了以下三种排序。</p><pre><code>            种类       速度    最坏情况        工作空间      稳定性&#39;quicksort&#39;（快速排序）    1    O(n^2)           0        否&#39;mergesort&#39;（归并排序）    2    O(n*log(n))      ~n/2        是&#39;heapsort&#39;（堆排序）        3    O(n*log(n))       0        否</code></pre><h3 id="numpy-sort"><a href="#numpy-sort" class="headerlink" title="numpy.sort()"></a>numpy.sort()</h3><p>numpy.sort() 函数返回输入数组的排序副本。函数格式如下： </p><pre class=" language-py"><code class="language-py">numpy.sort(a, axis, kind, order) </code></pre><pre><code>参数说明：a:         要排序的数组axis:     沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序kind:     默认为&#39;quicksort&#39;（快速排序）order:     如果数组包含字段，则是要排序的字段</code></pre><h3 id="numpy-argsort"><a href="#numpy-argsort" class="headerlink" title="numpy.argsort()"></a>numpy.argsort()</h3><p>numpy.argsort() 函数返回的是数组值从小到大的索引值。</p><h3 id="numpy-lexsort"><a href="#numpy-lexsort" class="headerlink" title="numpy.lexsort()"></a>numpy.lexsort()</h3><p>numpy.lexsort() 用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列 也就是多关键字排序   </p><pre class=" language-py"><code class="language-py">numpy.lexsort(a,b,c)</code></pre><p>按照优先级为c&gt;b&gt;a的优先级排序</p><p>其他的一些排序 <strong>msort、sort_complex、partition、argpartition</strong></p><pre><code>函数            描述msort(a)    数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。sort_complex(a)    对复数按照先实部后虚部的顺序进行排序。partition(a, kth[, axis, kind, order])    指定一个数，对数组进行分区argpartition(a, kth[, axis, kind, order])    可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</code></pre><h3 id="numpy-argmax-和-numpy-argmin"><a href="#numpy-argmax-和-numpy-argmin" class="headerlink" title="numpy.argmax() 和 numpy.argmin()"></a>numpy.argmax() 和 numpy.argmin()</h3><p>numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。 </p><h3 id="numpy-where"><a href="#numpy-where" class="headerlink" title="numpy.where()"></a>numpy.where()</h3><p>numpy.where()函数返回输入数组中满足给定条件的元素的索引。 </p><h3 id="numpy-extract"><a href="#numpy-extract" class="headerlink" title="numpy.extract()"></a>numpy.extract()</h3><p>numpy.extract() 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p><h2 id="十七-NumPy-字节交换及副本和视图"><a href="#十七-NumPy-字节交换及副本和视图" class="headerlink" title="十七. NumPy 字节交换及副本和视图"></a>十七. NumPy 字节交换及副本和视图</h2><p><strong>很有意思的大小端调换</strong></p><h3 id="numpy-ndarray-byteswap"><a href="#numpy-ndarray-byteswap" class="headerlink" title="numpy.ndarray.byteswap()"></a>numpy.ndarray.byteswap()</h3><p>numpy.ndarray.byteswap() 函数将 ndarray 中每个元素中的字节进行大小端转换。 用ndarray.byteswap(True)</p><p><strong>副本和视图的概念</strong><br>副本是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。 视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。</p><p><strong>场景</strong> </p><pre><code>视图一般发生在：    1、numpy 的切片操作返回原数据的视图。  2、调用 ndarray 的 view() 函数产生一个视图。 副本一般发生在： Python 序列的切片操作，调用deepCopy()函数。 调用 ndarray 的 copy() 函数产生一个副本。</code></pre><p>一般时候是无复制 简单的赋值不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。 此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p><h2 id="十八-NumPy-矩阵库-Matrix"><a href="#十八-NumPy-矩阵库-Matrix" class="headerlink" title="十八.NumPy 矩阵库(Matrix)"></a>十八.NumPy 矩阵库(Matrix)</h2><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。 矩阵里的元素可以是数字、符号或数学式。</p><h3 id="matlib-empty"><a href="#matlib-empty" class="headerlink" title="matlib.empty()"></a>matlib.empty()</h3><p>matlib.empty() 函数返回一个新的矩阵，语法格式为： numpy.matlib.empty(shape, dtype, order) 参数说明：<br>填充为随机数据</p><h3 id="numpy-matlib-zeros"><a href="#numpy-matlib-zeros" class="headerlink" title="numpy.matlib.zeros()"></a>numpy.matlib.zeros()</h3><p>numpy.matlib.zeros() 函数创建一个以 0 填充的矩阵。</p><h3 id="numpy-matlib-ones"><a href="#numpy-matlib-ones" class="headerlink" title="numpy.matlib.ones()"></a>numpy.matlib.ones()</h3><p>numpy.matlib.ones()函数创建一个以 1 填充的矩阵。</p><h3 id="numpy-matlib-eye"><a href="#numpy-matlib-eye" class="headerlink" title="numpy.matlib.eye()"></a>numpy.matlib.eye()</h3><p>numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。</p><pre class=" language-py"><code class="language-py">numpy.matlib.eye(n, M,k, dtype)</code></pre><pre><code>参数说明：n: 返回矩阵的行数M: 返回矩阵的列数，默认为 nk: 对角线的索引dtype: 数据类型</code></pre><h3 id="numpy-matlib-identity"><a href="#numpy-matlib-identity" class="headerlink" title="numpy.matlib.identity()"></a>numpy.matlib.identity()</h3><p>numpy.matlib.identity() 函数返回给定大小的单位矩阵。 单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。</p><h3 id="numpy-matlib-rand"><a href="#numpy-matlib-rand" class="headerlink" title="numpy.matlib.rand()"></a>numpy.matlib.rand()</h3><p>numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。</p><p>矩阵总是二维的，而 ndarray 是一个 n 维数组。 两个对象都是可互换的。</p><h2 id="十九-NumPy-线性代数"><a href="#十九-NumPy-线性代数" class="headerlink" title="十九.NumPy 线性代数"></a>十九.NumPy 线性代数</h2><p>NumPy 提供了线性代数函数库 <strong>linalg</strong>，该库包含了线性代数所需的所有功能：</p><pre><code>函数            描述dot            两个数组的点积，即元素对应相乘。vdot        两个向量的点积inner        两个数组的内积matmul        两个数组的矩阵积determinant    数组的行列式solve        求解线性矩阵方程inv            计算矩阵的乘法逆矩阵</code></pre><h3 id="numpy-dot"><a href="#numpy-dot" class="headerlink" title="numpy.dot()"></a>numpy.dot()</h3><p>numpy.dot()<br>对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；<br>对于二维数组，计算的是两个数组的矩阵乘积；<br>对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和：<br>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。 </p><pre class=" language-py"><code class="language-py">numpy.dot(a, b, out=None)  </code></pre><pre><code>参数说明： a : ndarray 数组 b : ndarray 数组 out : ndarray, 可选，用来保存dot()的计算结果</code></pre><h3 id="numpy-vdot"><a href="#numpy-vdot" class="headerlink" title="numpy.vdot()"></a>numpy.vdot()</h3><p>numpy.vdot() 函数是两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p><h3 id="numpy-inner"><a href="#numpy-inner" class="headerlink" title="numpy.inner()"></a>numpy.inner()</h3><p>numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><h3 id="numpy-matmul"><a href="#numpy-matmul" class="headerlink" title="numpy.matmul()"></a>numpy.matmul()</h3><p>numpy.matmul 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p><h3 id="numpy-linalg-det"><a href="#numpy-linalg-det" class="headerlink" title="numpy.linalg.det()"></a>numpy.linalg.det()</h3><p>numpy.linalg.det() 函数计算输入矩阵的行列式。</p><h3 id="numpy-linalg-solve"><a href="#numpy-linalg-solve" class="headerlink" title="numpy.linalg.solve()"></a>numpy.linalg.solve()</h3><p>numpy.linalg.solve() 函数给出了矩阵形式的线性方程的解。</p><h3 id="numpy-linalg-inv"><a href="#numpy-linalg-inv" class="headerlink" title="numpy.linalg.inv()"></a>numpy.linalg.inv()</h3><p>numpy.linalg.inv() 函数计算矩阵的乘法逆矩阵。<br><strong>逆矩阵（inverse matrix）</strong>：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E ，则我们称B是A的逆矩阵，而A则被称为可逆矩阵。<br>注：E为单位矩阵。</p><h2 id="二十-NumPy-IO"><a href="#二十-NumPy-IO" class="headerlink" title="二十.NumPy IO"></a>二十.NumPy IO</h2><p>Numpy 可以读写磁盘上的文本数据或二进制数据。 </p><p> NumPy 为 ndarray 对象引入了一个简单的文件格式：<strong>npy</strong>。<br> npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。   </p><p> 常用的 IO 函数有：<br> <strong>load()</strong> 和 <strong>save()</strong> 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。 savze() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。 loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等)</p><h3 id="numpy-save"><a href="#numpy-save" class="headerlink" title="numpy.save()"></a>numpy.save()</h3><p>numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。  </p><pre class=" language-py"><code class="language-py">numpy.save(file, arr, allowpickle=True, fiximports=True) </code></pre><pre><code>参数说明：  file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。  arr: 要保存的数组   allowpickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。   fiximports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。</code></pre><h3 id="np-savez"><a href="#np-savez" class="headerlink" title="np.savez()"></a>np.savez()</h3><p>numpy.savez() 函数将多个数组保存到以 npz 为扩展名的文件中。 </p><pre class=" language-py"><code class="language-py">numpy.savez(file, args, *kwds) </code></pre><pre><code>参数说明：  file：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，该扩展名会被自动加上。   args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr0, arr1, …　。  kwds: 要保存的数组使用关键字名称（别名）。</code></pre><h3 id="savetxt"><a href="#savetxt" class="headerlink" title="savetxt()"></a>savetxt()</h3><p>savetxt() 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt() 函数来获取数据。 </p><pre class=" language-py"><code class="language-py">np.loadtxt(FILENAME, dtype=int, delimiter=' ')np.savetxt(FILENAME, a, fmt="%d", delimiter=",")</code></pre><p> 注：参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</p><h2 id="二十一-一些其他的函数"><a href="#二十一-一些其他的函数" class="headerlink" title="二十一. 一些其他的函数"></a>二十一. 一些其他的函数</h2><h3 id="np-random-multivariate-normal"><a href="#np-random-multivariate-normal" class="headerlink" title="np.random.multivariate_normal"></a>np.random.multivariate_normal</h3><p>生成一个服从多元正态分布的数组</p><pre class=" language-py"><code class="language-py">multivariate_normal(mean, cov, size=None, check_valid=None, tol=None)</code></pre><pre><code>mean：均值，维度为1，必选参数；cov：协方差矩阵，必选参数；size： 指定生成矩阵的维度，若size=(1, 1, 2)，则输出的矩阵的 shape 即形状为 1X1X2XN（N为mean的长度）；check_valid：可取值 warn，raise以及ignore；tol：检查协方差矩阵奇异值时的公差，float类型；</code></pre><h3 id="np-diag"><a href="#np-diag" class="headerlink" title="np.diag"></a>np.diag</h3><p>提取对角线或构造对角线数组。</p><pre class=" language-py"><code class="language-py">numpy.diag（v，k = 0 ）</code></pre><pre><code>v : 数组，如果是二维数组，返回对角线元素；如果是一维数组，返回一个二维数组，v在其对角线上。k ：int ，可选， 对角线的偏移量。k=0,选择主对角线；k&gt;0 选择上方的对角线；反之，选择下方的对角线；</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first</title>
      <link href="/2020/03/30/first/"/>
      <url>/2020/03/30/first/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><h4 id="嘿嘿嘿"><a href="#嘿嘿嘿" class="headerlink" title="嘿嘿嘿"></a>嘿嘿嘿</h4>]]></content>
      
      
      <categories>
          
          <category> nancheng58的日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
